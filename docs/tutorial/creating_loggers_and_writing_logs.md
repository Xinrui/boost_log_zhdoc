## Creating loggers and writing logs

### Dedicated logger objects

现在我们已经定义了日志存储的位置和方式，是时候看看如何发出日志记录了。为了能够创建日志记录，首先必须创建一个日志源。这在我们的情况下就是一个简单的日志记录器对象：

```cpp
src::logger lg;
```

---

**📓注意**
 
细心的读者可能注意到，当我们尝试使用简单日志记录时并没有创建任何日志记录器。在这种情况下，库提供了一个日志记录器并在幕后使用。

---

与汇不同，源不需要在任何地方注册，因为它们直接与日志核心交互。还要注意，库提供了两种版本的日志记录器：线程安全和非线程安全。对于非线程安全的日志记录器，安全的做法是在不同的线程中通过不同的日志记录器实例进行日志记录，因此每个写入日志的线程应该有一个单独的日志记录器。线程安全的对应类型可以从多个线程并发访问，但这会涉及锁定，并且在激烈竞争的情况下可能会降低性能。线程安全的日志记录器类型名称中带有 `_mt` 后缀。

无论线程安全如何，库提供的所有日志记录器都是默认构造和可复制构造的，并支持交换，因此将日志记录器作为类的成员不会有任何问题。正如您稍后将看到的，这种方法可以带来额外的好处。

库提供了许多具有不同功能的日志记录器，如严重性和通道支持。这些功能可以组合在一起，以构造更复杂的日志记录器。

### Global logger objects

如果您无法将日志记录器放入您的类中（假设您没有），库提供了一种声明全局日志记录器的方法，如下所示：

```cpp
BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT(my_logger, src::logger_mt)
```

在这里，`my_logger` 是一个用户定义的标签名称，用于稍后检索日志记录器实例，而 `logger_mt` 是日志记录器类型。任何库提供的或用户定义的日志记录器类型都可以参与这种声明。然而，由于该日志记录器将只有一个实例，您通常会希望在多线程应用程序中使用线程安全的日志记录器作为全局日志记录器。

---

**❗提示**

还有其他宏可用于更复杂的情况。详细描述在这一节。

---

之后，您可以像这样获取日志记录器：

```cpp
src::logger_mt& lg = my_logger::get();
```

这样，`lg` 将在整个应用程序中引用该日志记录器的唯一实例，即使应用程序由多个模块组成。`get` 函数本身是线程安全的，因此无需额外的同步。

### Writing logs

无论您使用哪种类型的日志记录器（类成员或全局，线程安全或非线程安全），要将日志记录写入日志记录器，可以写如下代码：

```cpp
logging::record rec = lg.open_record();
if (rec)
{
    logging::record_ostream strm(rec);
    strm << "Hello, World!";
    strm.flush();
    lg.push_record(boost::move(rec));
}
```

在这里，`open_record` 函数调用确定要构造的记录是否将被至少一个汇消费。在此阶段应用过滤。如果记录将被消费，函数将返回一个有效的记录对象，可以填充记录消息字符串。之后可以通过调用 `push_record` 完成记录处理。

当然，上述语法可以很容易地包装在宏中，实际上，鼓励用户编写自己的宏，而不是直接使用 C++ 日志记录器接口。上面的日志记录可以写成：

```cpp
BOOST_LOG(lg) << "Hello, World!";
```

看起来短一些，不是吗？`BOOST_LOG` 宏及其他类似宏由库定义。它自动提供一个标准库样式的输出流，以便使用普通的插入表达式格式化消息。编写、编译并执行所有代码后，您应该能够在 "sample.log" 文件中看到 "Hello, World!" 记录。您将在[此处](https://www.boost.org/doc/libs/1_86_0/libs/log/example/doc/tutorial_logging.cpp)找到本节的完整代码。
